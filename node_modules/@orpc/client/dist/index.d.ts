import { N as NestedClient, C as ClientLink, I as InferClientContext, a as ClientContext, b as ClientOptions, c as ClientPromiseResult, F as FriendlyClientOptions } from './shared/client.4TS_0JaO.js';
export { f as Client, e as ClientRest, d as HTTPMethod, H as HTTPPath } from './shared/client.4TS_0JaO.js';
import { Promisable, MaybeOptionalOptions, ThrowableError } from '@orpc/shared';
export { Registry, ThrowableError, onError, onFinish, onStart, onSuccess } from '@orpc/shared';
export { ErrorEvent } from '@orpc/standard-server';

interface createORPCClientOptions {
    /**
     * Use as base path for all procedure, useful when you only want to call a subset of the procedure.
     */
    path?: string[];
}
/**
 * Create a oRPC client-side client from a link.
 *
 * @see {@link https://orpc.unnoq.com/docs/client/client-side Client-side Client Docs}
 */
declare function createORPCClient<T extends NestedClient<any>>(link: ClientLink<InferClientContext<T>>, options?: createORPCClientOptions): T;

/**
 * DynamicLink provides a way to dynamically resolve and delegate calls to other ClientLinks
 * based on the request path, input, and context.
 *
 * @see {@link https://orpc.unnoq.com/docs/client/dynamic-link Dynamic Link Docs}
 */
declare class DynamicLink<TClientContext extends ClientContext> implements ClientLink<TClientContext> {
    private readonly linkResolver;
    constructor(linkResolver: (options: ClientOptions<TClientContext>, path: readonly string[], input: unknown) => Promisable<ClientLink<TClientContext>>);
    call(path: readonly string[], input: unknown, options: ClientOptions<TClientContext>): Promise<unknown>;
}

declare const COMMON_ORPC_ERROR_DEFS: {
    readonly BAD_REQUEST: {
        readonly status: 400;
        readonly message: "Bad Request";
    };
    readonly UNAUTHORIZED: {
        readonly status: 401;
        readonly message: "Unauthorized";
    };
    readonly FORBIDDEN: {
        readonly status: 403;
        readonly message: "Forbidden";
    };
    readonly NOT_FOUND: {
        readonly status: 404;
        readonly message: "Not Found";
    };
    readonly METHOD_NOT_SUPPORTED: {
        readonly status: 405;
        readonly message: "Method Not Supported";
    };
    readonly NOT_ACCEPTABLE: {
        readonly status: 406;
        readonly message: "Not Acceptable";
    };
    readonly TIMEOUT: {
        readonly status: 408;
        readonly message: "Request Timeout";
    };
    readonly CONFLICT: {
        readonly status: 409;
        readonly message: "Conflict";
    };
    readonly PRECONDITION_FAILED: {
        readonly status: 412;
        readonly message: "Precondition Failed";
    };
    readonly PAYLOAD_TOO_LARGE: {
        readonly status: 413;
        readonly message: "Payload Too Large";
    };
    readonly UNSUPPORTED_MEDIA_TYPE: {
        readonly status: 415;
        readonly message: "Unsupported Media Type";
    };
    readonly UNPROCESSABLE_CONTENT: {
        readonly status: 422;
        readonly message: "Unprocessable Content";
    };
    readonly TOO_MANY_REQUESTS: {
        readonly status: 429;
        readonly message: "Too Many Requests";
    };
    readonly CLIENT_CLOSED_REQUEST: {
        readonly status: 499;
        readonly message: "Client Closed Request";
    };
    readonly INTERNAL_SERVER_ERROR: {
        readonly status: 500;
        readonly message: "Internal Server Error";
    };
    readonly NOT_IMPLEMENTED: {
        readonly status: 501;
        readonly message: "Not Implemented";
    };
    readonly BAD_GATEWAY: {
        readonly status: 502;
        readonly message: "Bad Gateway";
    };
    readonly SERVICE_UNAVAILABLE: {
        readonly status: 503;
        readonly message: "Service Unavailable";
    };
    readonly GATEWAY_TIMEOUT: {
        readonly status: 504;
        readonly message: "Gateway Timeout";
    };
};
type CommonORPCErrorCode = keyof typeof COMMON_ORPC_ERROR_DEFS;
type ORPCErrorCode = CommonORPCErrorCode | (string & {});
declare function fallbackORPCErrorStatus(code: ORPCErrorCode, status: number | undefined): number;
declare function fallbackORPCErrorMessage(code: ORPCErrorCode, message: string | undefined): string;
type ORPCErrorOptions<TData> = ErrorOptions & {
    defined?: boolean;
    status?: number;
    message?: string;
} & (undefined extends TData ? {
    data?: TData;
} : {
    data: TData;
});
declare class ORPCError<TCode extends ORPCErrorCode, TData> extends Error {
    readonly defined: boolean;
    readonly code: TCode;
    readonly status: number;
    readonly data: TData;
    constructor(code: TCode, ...[options]: MaybeOptionalOptions<ORPCErrorOptions<TData>>);
    toJSON(): ORPCErrorJSON<TCode, TData>;
}
type ORPCErrorJSON<TCode extends string, TData> = Pick<ORPCError<TCode, TData>, 'defined' | 'code' | 'status' | 'message' | 'data'>;
declare function isDefinedError<T>(error: T): error is Extract<T, ORPCError<any, any>>;
declare function toORPCError(error: unknown): ORPCError<any, any>;
declare function isORPCErrorStatus(status: number): boolean;
declare function isORPCErrorJson(json: unknown): json is ORPCErrorJSON<ORPCErrorCode, unknown>;
declare function createORPCErrorFromJson<TCode extends ORPCErrorCode, TData>(json: ORPCErrorJSON<TCode, TData>, options?: ErrorOptions): ORPCError<TCode, TData>;

declare function mapEventIterator<TYield, TReturn, TNext, TMap = TYield | TReturn>(iterator: AsyncIterator<TYield, TReturn, TNext>, maps: {
    value: (value: NoInfer<TYield | TReturn>, done: boolean | undefined) => Promise<TMap>;
    error: (error: unknown) => Promise<unknown>;
}): AsyncGenerator<TMap, TMap, TNext>;

type SafeResult<TOutput, TError> = [error: null, data: TOutput, isDefined: false, isSuccess: true] & {
    error: null;
    data: TOutput;
    isDefined: false;
    isSuccess: true;
} | [error: Exclude<TError, ORPCError<any, any>>, data: undefined, isDefined: false, isSuccess: false] & {
    error: Exclude<TError, ORPCError<any, any>>;
    data: undefined;
    isDefined: false;
    isSuccess: false;
} | [error: Extract<TError, ORPCError<any, any>>, data: undefined, isDefined: true, isSuccess: false] & {
    error: Extract<TError, ORPCError<any, any>>;
    data: undefined;
    isDefined: true;
    isSuccess: false;
};
/**
 * Works like try/catch, but can infer error types.
 *
 * @info support both tuple `[error, data, isDefined, isSuccess]` and object `{ error, data, isDefined, isSuccess }` styles.
 * @see {@link https://orpc.unnoq.com/docs/client/error-handling Client Error Handling Docs}
 */
declare function safe<TOutput, TError = ThrowableError>(promise: ClientPromiseResult<TOutput, TError>): Promise<SafeResult<TOutput, TError>>;
declare function resolveFriendlyClientOptions<T extends ClientContext>(options: FriendlyClientOptions<T>): ClientOptions<T>;

export { COMMON_ORPC_ERROR_DEFS, ClientContext, ClientLink, ClientOptions, ClientPromiseResult, DynamicLink, FriendlyClientOptions, InferClientContext, NestedClient, ORPCError, createORPCClient, createORPCErrorFromJson, fallbackORPCErrorMessage, fallbackORPCErrorStatus, isDefinedError, isORPCErrorJson, isORPCErrorStatus, mapEventIterator, resolveFriendlyClientOptions, safe, toORPCError };
export type { CommonORPCErrorCode, ORPCErrorCode, ORPCErrorJSON, ORPCErrorOptions, SafeResult, createORPCClientOptions };
