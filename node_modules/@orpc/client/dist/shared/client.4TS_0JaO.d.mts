import { PromiseWithError } from '@orpc/shared';

type HTTPPath = `/${string}`;
type HTTPMethod = 'HEAD' | 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
type ClientContext = Record<PropertyKey, any>;
interface ClientOptions<T extends ClientContext> {
    signal?: AbortSignal;
    lastEventId?: string | undefined;
    context: T;
}
type FriendlyClientOptions<T extends ClientContext> = Omit<ClientOptions<T>, 'context'> & (Record<never, never> extends T ? {
    context?: T;
} : {
    context: T;
});
type ClientRest<TClientContext extends ClientContext, TInput> = Record<never, never> extends TClientContext ? undefined extends TInput ? [input?: TInput, options?: FriendlyClientOptions<TClientContext>] : [input: TInput, options?: FriendlyClientOptions<TClientContext>] : [input: TInput, options: FriendlyClientOptions<TClientContext>];
type ClientPromiseResult<TOutput, TError> = PromiseWithError<TOutput, TError>;
interface Client<TClientContext extends ClientContext, TInput, TOutput, TError> {
    (...rest: ClientRest<TClientContext, TInput>): ClientPromiseResult<TOutput, TError>;
}
type NestedClient<TClientContext extends ClientContext> = Client<TClientContext, any, any, any> | {
    [k: string]: NestedClient<TClientContext>;
};
type InferClientContext<T extends NestedClient<any>> = T extends NestedClient<infer U> ? U : never;
interface ClientLink<TClientContext extends ClientContext> {
    call: (path: readonly string[], input: unknown, options: ClientOptions<TClientContext>) => Promise<unknown>;
}

export type { ClientLink as C, FriendlyClientOptions as F, HTTPPath as H, InferClientContext as I, NestedClient as N, ClientContext as a, ClientOptions as b, ClientPromiseResult as c, HTTPMethod as d, ClientRest as e, Client as f };
