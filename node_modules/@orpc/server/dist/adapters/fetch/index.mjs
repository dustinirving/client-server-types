import { ORPCError } from '@orpc/client';
import { toArray, intercept, resolveMaybeOptionalOptions } from '@orpc/shared';
import { toStandardLazyRequest, toFetchResponse } from '@orpc/standard-server-fetch';
import { r as resolveFriendlyStandardHandleOptions } from '../../shared/server.BVwwTHyO.mjs';
import '@orpc/contract';
import { C as CompositeStandardHandlerPlugin, b as StandardRPCHandler } from '../../shared/server.SxlTJfG2.mjs';
import '@orpc/client/standard';
import '@orpc/standard-server/batch';
import '@orpc/standard-server';
import { S as StrictGetMethodPlugin } from '../../shared/server.BW-nUGgA.mjs';
import '../../shared/server.DG7Tamti.mjs';

class BodyLimitPlugin {
  maxBodySize;
  constructor(options) {
    this.maxBodySize = options.maxBodySize;
  }
  initRuntimeAdapter(options) {
    options.adapterInterceptors ??= [];
    options.adapterInterceptors.push(async (options2) => {
      if (!options2.request.body) {
        return options2.next();
      }
      let currentBodySize = 0;
      const rawReader = options2.request.body.getReader();
      const reader = new ReadableStream({
        start: async (controller) => {
          try {
            if (Number(options2.request.headers.get("content-length")) > this.maxBodySize) {
              controller.error(new ORPCError("PAYLOAD_TOO_LARGE"));
              return;
            }
            while (true) {
              const { done, value } = await rawReader.read();
              if (done) {
                break;
              }
              currentBodySize += value.length;
              if (currentBodySize > this.maxBodySize) {
                controller.error(new ORPCError("PAYLOAD_TOO_LARGE"));
                break;
              }
              controller.enqueue(value);
            }
          } finally {
            controller.close();
          }
        }
      });
      const requestInit = { body: reader, duplex: "half" };
      return options2.next({
        ...options2,
        request: new Request(options2.request, requestInit)
      });
    });
  }
}

class CompositeFetchHandlerPlugin extends CompositeStandardHandlerPlugin {
  initRuntimeAdapter(options) {
    for (const plugin of this.plugins) {
      plugin.initRuntimeAdapter?.(options);
    }
  }
}

class FetchHandler {
  constructor(standardHandler, options = {}) {
    this.standardHandler = standardHandler;
    const plugin = new CompositeFetchHandlerPlugin(options.plugins);
    plugin.initRuntimeAdapter(options);
    this.adapterInterceptors = toArray(options.adapterInterceptors);
    this.toFetchResponseOptions = options;
  }
  toFetchResponseOptions;
  adapterInterceptors;
  async handle(request, ...rest) {
    return intercept(
      this.adapterInterceptors,
      {
        ...resolveFriendlyStandardHandleOptions(resolveMaybeOptionalOptions(rest)),
        request,
        toFetchResponseOptions: this.toFetchResponseOptions
      },
      async ({ request: request2, toFetchResponseOptions, ...options }) => {
        const standardRequest = toStandardLazyRequest(request2);
        const result = await this.standardHandler.handle(standardRequest, options);
        if (!result.matched) {
          return result;
        }
        return {
          matched: true,
          response: toFetchResponse(result.response, toFetchResponseOptions)
        };
      }
    );
  }
}

class RPCHandler extends FetchHandler {
  constructor(router, options = {}) {
    if (options.strictGetMethodPluginEnabled ?? true) {
      options.plugins ??= [];
      options.plugins.push(new StrictGetMethodPlugin());
    }
    super(new StandardRPCHandler(router, options), options);
  }
}

export { BodyLimitPlugin, CompositeFetchHandlerPlugin, FetchHandler, RPCHandler };
