import { ORPCError } from '@orpc/client';
import { toArray, intercept, resolveMaybeOptionalOptions } from '@orpc/shared';
import { toStandardLazyRequest, sendStandardResponse } from '@orpc/standard-server-node';
import { r as resolveFriendlyStandardHandleOptions } from '../../shared/server.BVwwTHyO.mjs';
import '@orpc/contract';
import { C as CompositeStandardHandlerPlugin, b as StandardRPCHandler } from '../../shared/server.SxlTJfG2.mjs';
import '@orpc/client/standard';
import '@orpc/standard-server/batch';
import '@orpc/standard-server';
import { S as StrictGetMethodPlugin } from '../../shared/server.BW-nUGgA.mjs';
import '../../shared/server.DG7Tamti.mjs';

class BodyLimitPlugin {
  maxBodySize;
  constructor(options) {
    this.maxBodySize = options.maxBodySize;
  }
  initRuntimeAdapter(options) {
    options.adapterInterceptors ??= [];
    options.adapterInterceptors.push(async (options2) => {
      let isHeaderChecked = false;
      const checkHeader = () => {
        if (!isHeaderChecked && Number(options2.request.headers["content-length"]) > this.maxBodySize) {
          throw new ORPCError("PAYLOAD_TOO_LARGE");
        }
        isHeaderChecked = true;
      };
      const originalEmit = options2.request.emit.bind(options2.request);
      let currentBodySize = 0;
      options2.request.emit = (event, ...args) => {
        if (event === "data") {
          checkHeader();
          currentBodySize += args[0].length;
          if (currentBodySize > this.maxBodySize) {
            throw new ORPCError("PAYLOAD_TOO_LARGE");
          }
        }
        return originalEmit(event, ...args);
      };
      return options2.next();
    });
  }
}

class CompositeNodeHttpHandlerPlugin extends CompositeStandardHandlerPlugin {
  initRuntimeAdapter(options) {
    for (const plugin of this.plugins) {
      plugin.initRuntimeAdapter?.(options);
    }
  }
}

class NodeHttpHandler {
  constructor(standardHandler, options = {}) {
    this.standardHandler = standardHandler;
    const plugin = new CompositeNodeHttpHandlerPlugin(options.plugins);
    plugin.initRuntimeAdapter(options);
    this.adapterInterceptors = toArray(options.adapterInterceptors);
    this.sendStandardResponseOptions = options;
  }
  sendStandardResponseOptions;
  adapterInterceptors;
  async handle(request, response, ...rest) {
    return intercept(
      this.adapterInterceptors,
      {
        ...resolveFriendlyStandardHandleOptions(resolveMaybeOptionalOptions(rest)),
        request,
        response,
        sendStandardResponseOptions: this.sendStandardResponseOptions
      },
      async ({ request: request2, response: response2, sendStandardResponseOptions, ...options }) => {
        const standardRequest = toStandardLazyRequest(request2, response2);
        const result = await this.standardHandler.handle(standardRequest, options);
        if (!result.matched) {
          return { matched: false };
        }
        await sendStandardResponse(response2, result.response, sendStandardResponseOptions);
        return { matched: true };
      }
    );
  }
}

class RPCHandler extends NodeHttpHandler {
  constructor(router, options = {}) {
    if (options.strictGetMethodPluginEnabled ?? true) {
      options.plugins ??= [];
      options.plugins.push(new StrictGetMethodPlugin());
    }
    super(new StandardRPCHandler(router, options), options);
  }
}

export { BodyLimitPlugin, CompositeNodeHttpHandlerPlugin, NodeHttpHandler, RPCHandler };
