import { ORPCErrorJSON, ORPCError, Client, ClientContext, HTTPPath, ClientPromiseResult } from '@orpc/client';
export { ClientContext, HTTPMethod, HTTPPath, ORPCError, isDefinedError, safe } from '@orpc/client';
import { AnySchema, ErrorMap, InferSchemaInput, InferSchemaOutput, ErrorFromErrorMap, Meta, MergedErrorMap, Route, EnhanceRouteOptions, AnyContractRouter, AnyContractProcedure, Schema, ContractRouter, ContractProcedureDef, ContractProcedure, InferContractRouterErrorMap, InferContractRouterMeta } from '@orpc/contract';
export { ContractProcedure, ContractProcedureDef, ContractRouter, ErrorMap, ErrorMapItem, InferSchemaInput, InferSchemaOutput, InputStructure, MergedErrorMap, Meta, OutputStructure, Route, Schema, ValidationError, eventIterator, type } from '@orpc/contract';
import { ThrowableError, IntersectPick, MaybeOptionalOptions } from '@orpc/shared';
export { IntersectPick, Registry, ThrowableError, onError, onFinish, onStart, onSuccess } from '@orpc/shared';
import { C as Context, P as Procedure, M as Middleware, O as ORPCErrorConstructorMap, a as MergedInitialContext, b as MergedCurrentContext, c as MapInputMiddleware, d as CreateProcedureClientOptions, e as ProcedureClient, A as AnyMiddleware, L as Lazyable, f as AnyRouter, g as Lazy, h as AnyProcedure, i as ProcedureHandler, R as Router, I as InferRouterInitialContext } from './shared/server.DPWk5pjW.js';
export { J as InferRouterCurrentContexts, H as InferRouterInitialContexts, K as InferRouterInputs, N as InferRouterOutputs, n as LAZY_SYMBOL, o as LazyMeta, w as MiddlewareNextFn, t as MiddlewareNextFnOptions, y as MiddlewareOptions, x as MiddlewareOutputFn, s as MiddlewareResult, k as ORPCErrorConstructorMapItem, j as ORPCErrorConstructorMapItemOptions, F as ProcedureClientInterceptorOptions, D as ProcedureDef, B as ProcedureHandlerOptions, l as createORPCErrorConstructorMap, G as createProcedureClient, r as getLazyMeta, q as isLazy, E as isProcedure, p as lazy, m as mergeCurrentContext, z as middlewareOutputFn, u as unlazy, v as validateORPCError } from './shared/server.DPWk5pjW.js';
export { getEventMeta, withEventMeta } from '@orpc/standard-server';

type ActionableError<T> = T extends ORPCError<infer U, infer V> ? ORPCErrorJSON<U, V> & {
    defined: true;
} : ORPCErrorJSON<string, unknown> & {
    defined: false;
};
type UnactionableError<T> = T extends {
    defined: true;
} & ORPCErrorJSON<infer U, infer V> ? ORPCError<U, V> : ThrowableError;
type ActionableClientRest<TInput> = [input: TInput] | (undefined extends TInput ? [input?: TInput] : [input: TInput]);
type ActionableClientResult<TOutput, TError extends ORPCErrorJSON<any, any>> = [error: null, data: TOutput] | [error: TError, data: undefined];
interface ActionableClient<TInput, TOutput, TError extends ORPCErrorJSON<any, any>> {
    (...rest: ActionableClientRest<TInput>): Promise<ActionableClientResult<TOutput, TError>>;
}
type ProcedureActionableClient<TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap> = ActionableClient<InferSchemaInput<TInputSchema>, InferSchemaOutput<TOutputSchema>, ActionableError<ErrorFromErrorMap<TErrorMap>>>;
declare function createActionableClient<TInput, TOutput, TError>(client: Client<Record<never, never>, TInput, TOutput, TError>): ActionableClient<TInput, TOutput, ActionableError<TError>>;

declare class DecoratedProcedure<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> extends Procedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> {
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    errors<U extends ErrorMap>(errors: U): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    meta(meta: TMeta): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    route(route: Route): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): DecoratedProcedure<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): DecoratedProcedure<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Make this procedure callable (works like a function while still being a procedure).
     *
     * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}
     */
    callable<TClientContext extends ClientContext>(...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, TClientContext>>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> & ProcedureClient<TClientContext, TInputSchema, TOutputSchema, TErrorMap>;
    /**
     * Make this procedure compatible with server action.
     *
     * @see {@link https://orpc.unnoq.com/docs/server-action Server Action Docs}
     */
    actionable(...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, Record<never, never>>>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> & ProcedureActionableClient<TInputSchema, TOutputSchema, TErrorMap>;
}

declare function getRouter<T extends Lazyable<AnyRouter | undefined>>(router: T, path: readonly string[]): T extends Lazy<any> ? Lazy<AnyRouter | undefined> : Lazyable<AnyRouter | undefined>;
type AccessibleLazyRouter<T extends Lazyable<AnyRouter | undefined>> = T extends Lazy<infer U extends AnyRouter | undefined | Lazy<AnyRouter | undefined>> ? AccessibleLazyRouter<U> : T extends AnyProcedure | undefined ? Lazy<T> : Lazy<T> & {
    [K in keyof T]: T[K] extends Lazyable<AnyRouter> ? AccessibleLazyRouter<T[K]> : never;
};
declare function createAccessibleLazyRouter<T extends Lazy<AnyRouter | undefined>>(lazied: T): AccessibleLazyRouter<T>;
type EnhancedRouter<T extends Lazyable<AnyRouter>, TInitialContext extends Context, TCurrentContext extends Context, TErrorMap extends ErrorMap> = T extends Lazy<infer U extends AnyRouter> ? AccessibleLazyRouter<EnhancedRouter<U, TInitialContext, TCurrentContext, TErrorMap>> : T extends Procedure<infer UInitialContext, infer UCurrentContext, infer UInputSchema, infer UOutputSchema, infer UErrorMap, infer UMeta> ? Procedure<MergedInitialContext<TInitialContext, UInitialContext, TCurrentContext>, UCurrentContext, UInputSchema, UOutputSchema, MergedErrorMap<TErrorMap, UErrorMap>, UMeta> : {
    [K in keyof T]: T[K] extends Lazyable<AnyRouter> ? EnhancedRouter<T[K], TInitialContext, TCurrentContext, TErrorMap> : never;
};
interface EnhanceRouterOptions<TErrorMap extends ErrorMap> extends EnhanceRouteOptions {
    middlewares: readonly AnyMiddleware[];
    errorMap: TErrorMap;
    dedupeLeadingMiddlewares: boolean;
}
declare function enhanceRouter<T extends Lazyable<AnyRouter>, TInitialContext extends Context, TCurrentContext extends Context, TErrorMap extends ErrorMap>(router: T, options: EnhanceRouterOptions<TErrorMap>): EnhancedRouter<T, TInitialContext, TCurrentContext, TErrorMap>;
interface TraverseContractProceduresOptions {
    router: AnyContractRouter | AnyRouter;
    path: readonly string[];
}
interface ContractProcedureCallbackOptions {
    contract: AnyContractProcedure;
    path: readonly string[];
}
interface LazyTraverseContractProceduresOptions {
    router: Lazy<AnyRouter>;
    path: readonly string[];
}
declare function traverseContractProcedures(options: TraverseContractProceduresOptions, callback: (options: ContractProcedureCallbackOptions) => void, lazyOptions?: LazyTraverseContractProceduresOptions[]): LazyTraverseContractProceduresOptions[];
declare function resolveContractProcedures(options: TraverseContractProceduresOptions, callback: (options: ContractProcedureCallbackOptions) => void): Promise<void>;
type UnlaziedRouter<T extends AnyRouter> = T extends AnyProcedure ? T : {
    [K in keyof T]: T[K] extends Lazyable<infer U extends AnyRouter> ? UnlaziedRouter<U> : never;
};
declare function unlazyRouter<T extends AnyRouter>(router: T): Promise<UnlaziedRouter<T>>;

interface BuilderWithMiddlewares<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): BuilderWithMiddlewares<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): BuilderWithMiddlewares<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): BuilderWithMiddlewares<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the input validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
     */
    'input'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, USchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the output validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
     */
    'output'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, USchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'<UFuncOutput>(handler: ProcedureHandler<TCurrentContext, unknown, UFuncOutput, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, Schema<UFuncOutput, UFuncOutput>, TErrorMap, TMeta>;
    /**
     * Prefixes all procedures in the router.
     * The provided prefix is post-appended to any existing router prefix.
     *
     * @note This option does not affect procedures that do not define a path in their route definition.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
     */
    'prefix'(prefix: HTTPPath): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Adds tags to all procedures in the router.
     * This helpful when you want to group procedures together in the OpenAPI specification.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
     */
    'tag'(...tags: string[]): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    'router'<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, TErrorMap>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    'lazy'<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, TErrorMap>;
}
interface ProcedureBuilder<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureBuilder<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the input validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
     */
    'input'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, USchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the output validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
     */
    'output'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, USchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'<UFuncOutput>(handler: ProcedureHandler<TCurrentContext, unknown, UFuncOutput, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, Schema<UFuncOutput, UFuncOutput>, TErrorMap, TMeta>;
}
interface ProcedureBuilderWithInput<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureBuilderWithInput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): ProcedureBuilderWithInput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the output validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
     */
    'output'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, TInputSchema, USchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'<UFuncOutput>(handler: ProcedureHandler<TCurrentContext, InferSchemaOutput<TInputSchema>, UFuncOutput, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, Schema<UFuncOutput, UFuncOutput>, TErrorMap, TMeta>;
}
interface ProcedureBuilderWithOutput<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureBuilderWithOutput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the input validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
     */
    'input'<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, USchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'(handler: ProcedureHandler<TCurrentContext, unknown, InferSchemaInput<TOutputSchema>, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
}
interface ProcedureBuilderWithInputOutput<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureBuilderWithInputOutput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): ProcedureBuilderWithInputOutput<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    'meta'(meta: TMeta): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    'route'(route: Route): ProcedureBuilderWithInputOutput<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'(handler: ProcedureHandler<TCurrentContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
}
interface RouterBuilder<TInitialContext extends Context, TCurrentContext extends Context, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': EnhanceRouterOptions<TErrorMap>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    'errors'<U extends ErrorMap>(errors: U): RouterBuilder<TInitialContext, TCurrentContext, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): RouterBuilder<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TErrorMap, TMeta>;
    /**
     * Prefixes all procedures in the router.
     * The provided prefix is post-appended to any existing router prefix.
     *
     * @note This option does not affect procedures that do not define a path in their route definition.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
     */
    'prefix'(prefix: HTTPPath): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Adds tags to all procedures in the router.
     * This helpful when you want to group procedures together in the OpenAPI specification.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
     */
    'tag'(...tags: string[]): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    'router'<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, TErrorMap>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    'lazy'<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, TErrorMap>;
}

interface DecoratedMiddleware<TInContext extends Context, TOutContext extends Context, TInput, TOutput, TErrorConstructorMap extends ORPCErrorConstructorMap<any>, TMeta extends Meta> extends Middleware<TInContext, TOutContext, TInput, TOutput, TErrorConstructorMap, TMeta> {
    /**
     * Change the expected input type by providing a map function.
     */
    mapInput<UInput>(map: MapInputMiddleware<UInput, TInput>): DecoratedMiddleware<TInContext, TOutContext, UInput, TOutput, TErrorConstructorMap, TMeta>;
    /**
     * Concatenates two middlewares.
     *
     * @info Pass second argument to map the input.
     * @see {@link https://orpc.unnoq.com/docs/middleware#concatenation Middleware Concatenation Docs}
     */
    concat<UOutContext extends IntersectPick<MergedCurrentContext<TInContext, TOutContext>, UOutContext>, UInput extends TInput, UInContext extends Context = MergedCurrentContext<TInContext, TOutContext>>(middleware: Middleware<UInContext | MergedCurrentContext<TInContext, TOutContext>, UOutContext, UInput, TOutput, TErrorConstructorMap, TMeta>): DecoratedMiddleware<MergedInitialContext<TInContext, UInContext, MergedCurrentContext<TInContext, TOutContext>>, MergedCurrentContext<TOutContext, UOutContext>, UInput, TOutput, TErrorConstructorMap, TMeta>;
    /**
     * Concatenates two middlewares.
     *
     * @info Pass second argument to map the input.
     * @see {@link https://orpc.unnoq.com/docs/middleware#concatenation Middleware Concatenation Docs}
     */
    concat<UOutContext extends IntersectPick<MergedCurrentContext<TInContext, TOutContext>, UOutContext>, UInput extends TInput, UMappedInput, UInContext extends Context = MergedCurrentContext<TInContext, TOutContext>>(middleware: Middleware<UInContext | MergedCurrentContext<TInContext, TOutContext>, UOutContext, UMappedInput, TOutput, TErrorConstructorMap, TMeta>, mapInput: MapInputMiddleware<UInput, UMappedInput>): DecoratedMiddleware<MergedInitialContext<TInContext, UInContext, MergedCurrentContext<TInContext, TOutContext>>, MergedCurrentContext<TOutContext, UOutContext>, UInput, TOutput, TErrorConstructorMap, TMeta>;
}
declare function decorateMiddleware<TInContext extends Context, TOutContext extends Context, TInput, TOutput, TErrorConstructorMap extends ORPCErrorConstructorMap<any>, TMeta extends Meta>(middleware: Middleware<TInContext, TOutContext, TInput, TOutput, TErrorConstructorMap, TMeta>): DecoratedMiddleware<TInContext, TOutContext, TInput, TOutput, TErrorConstructorMap, TMeta>;

interface BuilderConfig {
    initialInputValidationIndex?: number;
    initialOutputValidationIndex?: number;
    dedupeLeadingMiddlewares?: boolean;
}
interface BuilderDef<TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> extends ContractProcedureDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>, EnhanceRouterOptions<TErrorMap> {
    middlewares: readonly AnyMiddleware[];
    inputValidationIndex: number;
    outputValidationIndex: number;
    config: BuilderConfig;
}
declare class Builder<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    /**
     * This property holds the defined options.
     */
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    constructor(def: BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>);
    /**
     * Sets or overrides the config.
     *
     * @see {@link https://orpc.unnoq.com/docs/lifecycle#middlewares-order Middlewares Order Docs}
     * @see {@link https://orpc.unnoq.com/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}
     */
    $config(config: BuilderConfig): Builder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Set or override the initial context.
     *
     * @see {@link https://orpc.unnoq.com/docs/context Context Docs}
     */
    $context<U extends Context>(): Builder<U & Record<never, never>, U, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or overrides the initial meta.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    $meta<U extends Meta>(initialMeta: U): Builder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, U & Record<never, never>>;
    /**
     * Sets or overrides the initial route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    $route(initialRoute: Route): Builder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or overrides the initial input schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#initial-configuration Initial Procedure Configuration Docs}
     */
    $input<U extends AnySchema>(initialInputSchema?: U): Builder<TInitialContext, TCurrentContext, U, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Creates a middleware.
     *
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    middleware<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, TInput, TOutput = any>(// = any here is important to make middleware can be used in any output by default
    middleware: Middleware<TInitialContext, UOutContext, TInput, TOutput, ORPCErrorConstructorMap<TErrorMap>, TMeta>): DecoratedMiddleware<TInitialContext, UOutContext, TInput, TOutput, any, TMeta>;
    /**
     * Adds type-safe custom errors.
     * The provided errors are spared-merged with any existing errors.
     *
     * @see {@link https://orpc.unnoq.com/docs/error-handling#type%E2%80%90safe-error-handling Type-Safe Error Handling Docs}
     */
    errors<U extends ErrorMap>(errors: U): Builder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, MergedErrorMap<TErrorMap, U>, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<TErrorMap>, TMeta>): BuilderWithMiddlewares<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the metadata.
     * The provided metadata is spared-merged with any existing metadata.
     *
     * @see {@link https://orpc.unnoq.com/docs/metadata Metadata Docs}
     */
    meta(meta: TMeta): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Sets or updates the route definition.
     * The provided route is spared-merged with any existing route.
     * This option is typically relevant when integrating with OpenAPI.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing OpenAPI Routing Docs}
     * @see {@link https://orpc.unnoq.com/docs/openapi/input-output-structure OpenAPI Input/Output Structure Docs}
     */
    route(route: Route): ProcedureBuilder<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the input validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Input Validation Docs}
     */
    input<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithInput<TInitialContext, TCurrentContext, USchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the output validation schema.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure#input-output-validation Output Validation Docs}
     */
    output<USchema extends AnySchema>(schema: USchema): ProcedureBuilderWithOutput<TInitialContext, TCurrentContext, TInputSchema, USchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    handler<UFuncOutput>(handler: ProcedureHandler<TCurrentContext, unknown, UFuncOutput, TErrorMap, TMeta>): DecoratedProcedure<TInitialContext, TCurrentContext, TInputSchema, Schema<UFuncOutput, UFuncOutput>, TErrorMap, TMeta>;
    /**
     * Prefixes all procedures in the router.
     * The provided prefix is post-appended to any existing router prefix.
     *
     * @note This option does not affect procedures that do not define a path in their route definition.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/routing#route-prefixes OpenAPI Route Prefixes Docs}
     */
    prefix(prefix: HTTPPath): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Adds tags to all procedures in the router.
     * This helpful when you want to group procedures together in the OpenAPI specification.
     *
     * @see {@link https://orpc.unnoq.com/docs/openapi/openapi-specification#operation-metadata OpenAPI Operation Metadata Docs}
     */
    tag(...tags: string[]): RouterBuilder<TInitialContext, TCurrentContext, TErrorMap, TMeta>;
    /**
     * Applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    router<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, TErrorMap>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    lazy<U extends Router<ContractRouter<TMeta>, TCurrentContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, TErrorMap>;
}
declare const os: Builder<Record<never, never>, Record<never, never>, Schema<unknown, unknown>, Schema<unknown, unknown>, Record<never, never>, Record<never, never>>;

interface Config {
    initialInputValidationIndex: number;
    initialOutputValidationIndex: number;
    dedupeLeadingMiddlewares: boolean;
}
declare function fallbackConfig<T extends keyof Config>(key: T, value?: Config[T]): Config[T];

/**
 * Like `DecoratedProcedure`, but removed all method that can change the contract.
 */
interface ImplementedProcedure<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> extends Procedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> {
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ImplementedProcedure<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): ImplementedProcedure<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Make this procedure callable (works like a function while still being a procedure).
     *
     * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}
     */
    callable<TClientContext extends ClientContext>(...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, TClientContext>>): ImplementedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> & ProcedureClient<TClientContext, TInputSchema, TOutputSchema, TErrorMap>;
    /**
     * Make this procedure compatible with server action.
     *
     * @see {@link https://orpc.unnoq.com/docs/server-action Server Action Docs}
     */
    actionable(...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, Record<never, never>>>): ImplementedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta> & ProcedureActionableClient<TInputSchema, TOutputSchema, TErrorMap>;
}
/**
 * Like `ProcedureBuilderWithoutHandler`, but removed all method that can change the contract.
 */
interface ProcedureImplementer<TInitialContext extends Context, TCurrentContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta> {
    '~orpc': BuilderDef<TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>): ProcedureImplementer<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @info Pass second argument to map the input.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    'use'<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInput, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, UInput, InferSchemaInput<TOutputSchema>, ORPCErrorConstructorMap<TErrorMap>, TMeta>, mapInput: MapInputMiddleware<InferSchemaOutput<TInputSchema>, UInput>): ProcedureImplementer<MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
    /**
     * Defines the handler of the procedure.
     *
     * @see {@link https://orpc.unnoq.com/docs/procedure Procedure Docs}
     */
    'handler'(handler: ProcedureHandler<TCurrentContext, InferSchemaOutput<TInputSchema>, InferSchemaInput<TOutputSchema>, TErrorMap, TMeta>): ImplementedProcedure<TInitialContext, TCurrentContext, TInputSchema, TOutputSchema, TErrorMap, TMeta>;
}

interface RouterImplementerWithMiddlewares<T extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> {
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<InferContractRouterErrorMap<T>>, InferContractRouterMeta<T>>): ImplementerInternalWithMiddlewares<T, MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>>;
    /**
     * Applies all of the previously defined options to the specified router.
     * And enforces the router match the contract.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    router<U extends Router<T, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, Record<never, never>>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     * And enforces the router match the contract.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    lazy<U extends Router<T, TInitialContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, Record<never, never>>;
}
type ImplementerInternalWithMiddlewares<TContract extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> = (TContract extends ContractProcedure<infer UInputSchema, infer UOutputSchema, infer UErrorMap, infer UMeta> ? ProcedureImplementer<TInitialContext, TCurrentContext, UInputSchema, UOutputSchema, UErrorMap, UMeta> : RouterImplementerWithMiddlewares<TContract, TInitialContext, TCurrentContext> & {
    [K in keyof TContract]: TContract[K] extends AnyContractRouter ? ImplementerInternalWithMiddlewares<TContract[K], TInitialContext, TCurrentContext> : never;
});

interface RouterImplementer<T extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> {
    /**
     * Creates a middleware.
     *
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    middleware<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, TInput, TOutput = any>(// = any here is important to make middleware can be used in any output by default
    middleware: Middleware<TInitialContext, UOutContext, TInput, TOutput, ORPCErrorConstructorMap<InferContractRouterErrorMap<T>>, InferContractRouterMeta<T>>): DecoratedMiddleware<TInitialContext, UOutContext, TInput, TOutput, any, InferContractRouterMeta<T>>;
    /**
     * Uses a middleware to modify the context or improve the pipeline.
     *
     * @info Supports both normal middleware and inline middleware implementations.
     * @note The current context must be satisfy middleware dependent-context
     * @see {@link https://orpc.unnoq.com/docs/middleware Middleware Docs}
     */
    use<UOutContext extends IntersectPick<TCurrentContext, UOutContext>, UInContext extends Context = TCurrentContext>(middleware: Middleware<UInContext | TCurrentContext, UOutContext, unknown, unknown, ORPCErrorConstructorMap<InferContractRouterErrorMap<T>>, InferContractRouterMeta<T>>): ImplementerInternalWithMiddlewares<T, MergedInitialContext<TInitialContext, UInContext, TCurrentContext>, MergedCurrentContext<TCurrentContext, UOutContext>>;
    /**
     * Applies all of the previously defined options to the specified router.
     * And enforces the router match the contract.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    router<U extends Router<T, TCurrentContext>>(router: U): EnhancedRouter<U, TInitialContext, TCurrentContext, Record<never, never>>;
    /**
     * Create a lazy router
     * And applies all of the previously defined options to the specified router.
     * And enforces the router match the contract.
     *
     * @see {@link https://orpc.unnoq.com/docs/router#extending-router Extending Router Docs}
     */
    lazy<U extends Router<T, TCurrentContext>>(loader: () => Promise<{
        default: U;
    }>): EnhancedRouter<Lazy<U>, TInitialContext, TCurrentContext, Record<never, never>>;
}
type ImplementerInternal<TContract extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> = (TContract extends ContractProcedure<infer UInputSchema, infer UOutputSchema, infer UErrorMap, infer UMeta> ? ProcedureImplementer<TInitialContext, TCurrentContext, UInputSchema, UOutputSchema, UErrorMap, UMeta> : RouterImplementer<TContract, TInitialContext, TCurrentContext> & {
    [K in keyof TContract]: TContract[K] extends AnyContractRouter ? ImplementerInternal<TContract[K], TInitialContext, TCurrentContext> : never;
});
declare function implementerInternal<T extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context>(contract: T, config: BuilderConfig, middlewares: AnyMiddleware[]): ImplementerInternal<T, TInitialContext, TCurrentContext>;
type Implementer<TContract extends AnyContractRouter, TInitialContext extends Context, TCurrentContext extends Context> = {
    /**
     * Set or override the initial context.
     *
     * @see {@link https://orpc.unnoq.com/docs/context Context Docs}
     */
    $context<U extends Context>(): Implementer<TContract, U & Record<never, never>, U>;
    /**
     * Sets or overrides the config.
     *
     * @see {@link https://orpc.unnoq.com/docs/lifecycle#middlewares-order Middlewares Order Docs}
     * @see {@link https://orpc.unnoq.com/docs/best-practices/dedupe-middleware#configuration Dedupe Middleware Docs}
     */
    $config(config: BuilderConfig): Implementer<TContract, TInitialContext, TCurrentContext>;
} & ImplementerInternal<TContract, TInitialContext, TCurrentContext>;
declare function implement<T extends AnyContractRouter, TContext extends Context = Record<never, never>>(contract: T, config?: BuilderConfig): Implementer<T, TContext, TContext>;

declare function isStartWithMiddlewares(middlewares: readonly AnyMiddleware[], compare: readonly AnyMiddleware[]): boolean;
declare function mergeMiddlewares(first: readonly AnyMiddleware[], second: readonly AnyMiddleware[], options: {
    dedupeLeading: boolean;
}): readonly AnyMiddleware[];
declare function addMiddleware(middlewares: readonly AnyMiddleware[], addition: AnyMiddleware): AnyMiddleware[];

declare function createAssertedLazyProcedure(lazied: Lazy<any>): Lazy<AnyProcedure>;
/**
 * Create a new procedure that ensure the contract is applied to the procedure.
 */
declare function createContractedProcedure(procedure: AnyProcedure, contract: AnyContractProcedure): AnyProcedure;
/**
 * Directly call a procedure without creating a client.
 *
 * @example
 * ```ts
 * const output = await call(getting, 'input')
 * const output = await call(getting, 'input', { context: { db: 'postgres' } })
 * ```
 *
 */
declare function call<TInitialContext extends Context, TInputSchema extends AnySchema, TOutputSchema extends AnySchema, TErrorMap extends ErrorMap, TMeta extends Meta>(procedure: Lazyable<Procedure<TInitialContext, any, TInputSchema, TOutputSchema, TErrorMap, TMeta>>, input: InferSchemaInput<TInputSchema>, ...rest: MaybeOptionalOptions<CreateProcedureClientOptions<TInitialContext, TOutputSchema, TErrorMap, TMeta, Record<never, never>>>): ClientPromiseResult<InferSchemaOutput<TOutputSchema>, ErrorFromErrorMap<TErrorMap>>;

type RouterClient<TRouter extends AnyRouter, TClientContext extends ClientContext = Record<never, never>> = TRouter extends Procedure<any, any, infer UInputSchema, infer UOutputSchema, infer UErrorMap, any> ? ProcedureClient<TClientContext, UInputSchema, UOutputSchema, UErrorMap> : {
    [K in keyof TRouter]: TRouter[K] extends Lazyable<infer U extends AnyRouter> ? RouterClient<U, TClientContext> : never;
};
/**
 * Create Server-side client from a router.
 *
 * @see {@link https://orpc.unnoq.com/docs/client/server-side Server-side Client Docs}
 */
declare function createRouterClient<T extends AnyRouter, TClientContext extends ClientContext>(router: Lazyable<T | undefined>, ...rest: MaybeOptionalOptions<CreateProcedureClientOptions<InferRouterInitialContext<T>, Schema<unknown, unknown>, ErrorMap, Meta, TClientContext>>): RouterClient<T, TClientContext>;

declare function setHiddenRouterContract<T extends Lazyable<AnyRouter>>(router: T, contract: AnyContractRouter): T;
declare function getHiddenRouterContract(router: Lazyable<AnyRouter | AnyContractRouter>): AnyContractRouter | undefined;

export { AnyMiddleware, AnyProcedure, AnyRouter, Builder, Context, CreateProcedureClientOptions, DecoratedProcedure, InferRouterInitialContext, Lazy, Lazyable, MapInputMiddleware, MergedCurrentContext, MergedInitialContext, Middleware, ORPCErrorConstructorMap, Procedure, ProcedureClient, ProcedureHandler, Router, addMiddleware, call, createAccessibleLazyRouter, createActionableClient, createAssertedLazyProcedure, createContractedProcedure, createRouterClient, decorateMiddleware, enhanceRouter, fallbackConfig, getHiddenRouterContract, getRouter, implement, implementerInternal, isStartWithMiddlewares, mergeMiddlewares, os, resolveContractProcedures, setHiddenRouterContract, traverseContractProcedures, unlazyRouter };
export type { AccessibleLazyRouter, ActionableClient, ActionableClientRest, ActionableClientResult, ActionableError, BuilderConfig, BuilderDef, BuilderWithMiddlewares, Config, ContractProcedureCallbackOptions, DecoratedMiddleware, EnhanceRouterOptions, EnhancedRouter, ImplementedProcedure, Implementer, ImplementerInternal, ImplementerInternalWithMiddlewares, LazyTraverseContractProceduresOptions, ProcedureActionableClient, ProcedureBuilder, ProcedureBuilderWithInput, ProcedureBuilderWithInputOutput, ProcedureBuilderWithOutput, ProcedureImplementer, RouterBuilder, RouterClient, RouterImplementer, RouterImplementerWithMiddlewares, TraverseContractProceduresOptions, UnactionableError, UnlaziedRouter };
