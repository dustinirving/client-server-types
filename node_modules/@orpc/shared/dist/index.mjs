export { group, guard, mapEntries, mapValues, omit } from 'radash';

function resolveMaybeOptionalOptions(rest) {
  return rest[0] ?? {};
}

function toArray(value) {
  return Array.isArray(value) ? value : value === void 0 || value === null ? [] : [value];
}
function splitInHalf(arr) {
  const half = Math.ceil(arr.length / 2);
  return [arr.slice(0, half), arr.slice(half)];
}

function once(fn) {
  let cached;
  return () => {
    if (cached) {
      return cached.result;
    }
    const result = fn();
    cached = { result };
    return result;
  };
}
function sequential(fn) {
  let lastOperationPromise = Promise.resolve();
  return (...args) => {
    return lastOperationPromise = lastOperationPromise.catch(() => {
    }).then(() => {
      return fn(...args);
    });
  };
}

class SequentialIdGenerator {
  nextId = 0;
  generate() {
    if (this.nextId === Number.MAX_SAFE_INTEGER) {
      this.nextId = 0;
      return Number.MAX_SAFE_INTEGER;
    }
    return this.nextId++;
  }
}

function onStart(callback) {
  return async (options, ...rest) => {
    await callback(options, ...rest);
    return await options.next();
  };
}
function onSuccess(callback) {
  return async (options, ...rest) => {
    const result = await options.next();
    await callback(result, options, ...rest);
    return result;
  };
}
function onError(callback) {
  return async (options, ...rest) => {
    try {
      return await options.next();
    } catch (error) {
      await callback(error, options, ...rest);
      throw error;
    }
  };
}
function onFinish(callback) {
  let state;
  return async (options, ...rest) => {
    try {
      const result = await options.next();
      state = [null, result, true];
      return result;
    } catch (error) {
      state = [error, void 0, false];
      throw error;
    } finally {
      await callback(state, options, ...rest);
    }
  };
}
async function intercept(interceptors, options, main) {
  const next = async (options2, index) => {
    const interceptor = interceptors[index];
    if (!interceptor) {
      return await main(options2);
    }
    return await interceptor({
      ...options2,
      next: (newOptions = options2) => next(newOptions, index + 1)
    });
  };
  return next(options, 0);
}

function isAsyncIteratorObject(maybe) {
  if (!maybe || typeof maybe !== "object") {
    return false;
  }
  return Symbol.asyncIterator in maybe && typeof maybe[Symbol.asyncIterator] === "function";
}
function createAsyncIteratorObject(next, cleanup) {
  let isExecuteComplete = false;
  let isDone = false;
  const iterator = {
    next: sequential(async () => {
      if (isDone) {
        return { done: true, value: void 0 };
      }
      try {
        const result = await next();
        if (result.done) {
          isDone = true;
        }
        return result;
      } catch (err) {
        isDone = true;
        throw err;
      } finally {
        if (isDone && !isExecuteComplete) {
          isExecuteComplete = true;
          await cleanup("next");
        }
      }
    }),
    async return(value) {
      isDone = true;
      if (!isExecuteComplete) {
        isExecuteComplete = true;
        await cleanup("return");
      }
      return { done: true, value };
    },
    async throw(err) {
      isDone = true;
      if (!isExecuteComplete) {
        isExecuteComplete = true;
        await cleanup("throw");
      }
      throw err;
    },
    /**
     * asyncDispose symbol only available in esnext, we should fallback to Symbol.for('asyncDispose')
     */
    async [Symbol.asyncDispose ?? Symbol.for("asyncDispose")]() {
      isDone = true;
      if (!isExecuteComplete) {
        isExecuteComplete = true;
        await cleanup("dispose");
      }
    },
    [Symbol.asyncIterator]() {
      return iterator;
    }
  };
  return iterator;
}

function parseEmptyableJSON(text) {
  if (!text) {
    return void 0;
  }
  return JSON.parse(text);
}
function stringifyJSON(value) {
  return JSON.stringify(value);
}

function findDeepMatches(check, payload, segments = [], maps = [], values = []) {
  if (check(payload)) {
    maps.push(segments);
    values.push(payload);
  } else if (Array.isArray(payload)) {
    payload.forEach((v, i) => {
      findDeepMatches(check, v, [...segments, i], maps, values);
    });
  } else if (isObject(payload)) {
    for (const key in payload) {
      findDeepMatches(check, payload[key], [...segments, key], maps, values);
    }
  }
  return { maps, values };
}
function isObject(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const proto = Object.getPrototypeOf(value);
  return proto === Object.prototype || !proto || !proto.constructor;
}
function isTypescriptObject(value) {
  return !!value && (typeof value === "object" || typeof value === "function");
}
function clone(value) {
  if (Array.isArray(value)) {
    return value.map(clone);
  }
  if (isObject(value)) {
    const result = {};
    for (const key in value) {
      result[key] = clone(value[key]);
    }
    return result;
  }
  return value;
}
function get(object, path) {
  let current = object;
  for (const key of path) {
    if (!isTypescriptObject(current)) {
      return void 0;
    }
    current = current[key];
  }
  return current;
}

class AsyncIdQueue {
  openIds = /* @__PURE__ */ new Set();
  items = /* @__PURE__ */ new Map();
  pendingPulls = /* @__PURE__ */ new Map();
  get length() {
    return this.openIds.size;
  }
  open(id) {
    this.openIds.add(id);
  }
  isOpen(id) {
    return this.openIds.has(id);
  }
  push(id, item) {
    this.assertOpen(id);
    const pending = this.pendingPulls.get(id);
    if (pending?.length) {
      pending.shift()[0](item);
      if (pending.length === 0) {
        this.pendingPulls.delete(id);
      }
    } else {
      const items = this.items.get(id);
      if (items) {
        items.push(item);
      } else {
        this.items.set(id, [item]);
      }
    }
  }
  async pull(id) {
    this.assertOpen(id);
    const items = this.items.get(id);
    if (items?.length) {
      const item = items.shift();
      if (items.length === 0) {
        this.items.delete(id);
      }
      return item;
    }
    return new Promise((resolve, reject) => {
      const waitingPulls = this.pendingPulls.get(id);
      const pending = [resolve, reject];
      if (waitingPulls) {
        waitingPulls.push(pending);
      } else {
        this.pendingPulls.set(id, [pending]);
      }
    });
  }
  close({ id, reason } = {}) {
    if (id === void 0) {
      this.pendingPulls.forEach((pendingPulls, id2) => {
        pendingPulls.forEach(([, reject]) => {
          reject(reason ?? new Error(`[AsyncIdQueue] Queue[${id2}] was closed or aborted while waiting for pulling.`));
        });
      });
      this.pendingPulls.clear();
      this.openIds.clear();
      this.items.clear();
      return;
    }
    this.pendingPulls.get(id)?.forEach(([, reject]) => {
      reject(reason ?? new Error(`[AsyncIdQueue] Queue[${id}] was closed or aborted while waiting for pulling.`));
    });
    this.pendingPulls.delete(id);
    this.openIds.delete(id);
    this.items.delete(id);
  }
  assertOpen(id) {
    if (!this.isOpen(id)) {
      throw new Error(`[AsyncIdQueue] Cannot access queue[${id}] because it is not open or aborted.`);
    }
  }
}

function value(value2, ...args) {
  if (typeof value2 === "function") {
    return value2(...args);
  }
  return value2;
}

export { AsyncIdQueue, SequentialIdGenerator, clone, createAsyncIteratorObject, findDeepMatches, get, intercept, isAsyncIteratorObject, isObject, isTypescriptObject, onError, onFinish, onStart, onSuccess, once, parseEmptyableJSON, resolveMaybeOptionalOptions, sequential, splitInHalf, stringifyJSON, toArray, value };
