import { Readable } from 'node:stream';
import { createAsyncIteratorObject, parseEmptyableJSON, isTypescriptObject, stringifyJSON, isAsyncIteratorObject, once } from '@orpc/shared';
import { EventDecoderStream, withEventMeta, ErrorEvent, encodeEventMessage, getEventMeta, getFilenameFromContentDisposition, flattenHeader, generateContentDisposition } from '@orpc/standard-server';

function toEventIterator(stream) {
  const eventStream = Readable.toWeb(stream).pipeThrough(new TextDecoderStream()).pipeThrough(new EventDecoderStream());
  const reader = eventStream.getReader();
  return createAsyncIteratorObject(async () => {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        return { done: true, value: void 0 };
      }
      switch (value.event) {
        case "message": {
          let message = parseEmptyableJSON(value.data);
          if (isTypescriptObject(message)) {
            message = withEventMeta(message, value);
          }
          return { done: false, value: message };
        }
        case "error": {
          let error = new ErrorEvent({
            data: parseEmptyableJSON(value.data)
          });
          error = withEventMeta(error, value);
          throw error;
        }
        case "done": {
          let done2 = parseEmptyableJSON(value.data);
          if (isTypescriptObject(done2)) {
            done2 = withEventMeta(done2, value);
          }
          return { done: true, value: done2 };
        }
      }
    }
  }, async () => {
    await reader.cancel();
  });
}
function toEventStream(iterator, options = {}) {
  const keepAliveEnabled = options.eventIteratorKeepAliveEnabled ?? true;
  const keepAliveInterval = options.eventIteratorKeepAliveInterval ?? 5e3;
  const keepAliveComment = options.eventIteratorKeepAliveComment ?? "";
  let cancelled = false;
  let timeout;
  const stream = new ReadableStream({
    async pull(controller) {
      try {
        if (keepAliveEnabled) {
          timeout = setInterval(() => {
            controller.enqueue(encodeEventMessage({
              comments: [keepAliveComment]
            }));
          }, keepAliveInterval);
        }
        const value = await iterator.next();
        clearInterval(timeout);
        if (cancelled) {
          return;
        }
        const meta = getEventMeta(value.value);
        if (!value.done || value.value !== void 0 || meta !== void 0) {
          controller.enqueue(encodeEventMessage({
            ...meta,
            event: value.done ? "done" : "message",
            data: stringifyJSON(value.value)
          }));
        }
        if (value.done) {
          controller.close();
        }
      } catch (err) {
        clearInterval(timeout);
        if (cancelled) {
          return;
        }
        controller.enqueue(encodeEventMessage({
          ...getEventMeta(err),
          event: "error",
          data: err instanceof ErrorEvent ? stringifyJSON(err.data) : void 0
        }));
        controller.close();
      }
    },
    async cancel() {
      cancelled = true;
      clearInterval(timeout);
      await iterator.return?.();
    }
  });
  return Readable.fromWeb(stream);
}

async function toStandardBody(req) {
  const method = req.method ?? "GET";
  if (method === "GET" || method === "HEAD") {
    return void 0;
  }
  const contentDisposition = req.headers["content-disposition"];
  const contentType = req.headers["content-type"];
  if (typeof contentDisposition === "string") {
    const fileName = getFilenameFromContentDisposition(contentDisposition) ?? "blob";
    return _streamToFile(req, fileName, contentType ?? "");
  }
  if (!contentType || contentType.startsWith("application/json")) {
    const text = await _streamToString(req);
    return parseEmptyableJSON(text);
  }
  if (contentType.startsWith("multipart/form-data")) {
    return _streamToFormData(req, contentType);
  }
  if (contentType.startsWith("application/x-www-form-urlencoded")) {
    const text = await _streamToString(req);
    return new URLSearchParams(text);
  }
  if (contentType.startsWith("text/event-stream")) {
    return toEventIterator(req);
  }
  if (contentType.startsWith("text/plain")) {
    return _streamToString(req);
  }
  return _streamToFile(req, "blob", contentType);
}
function toNodeHttpBody(body, headers, options = {}) {
  const currentContentDisposition = flattenHeader(headers["content-disposition"]);
  delete headers["content-type"];
  delete headers["content-disposition"];
  if (body === void 0) {
    return;
  }
  if (body instanceof Blob) {
    headers["content-type"] = body.type;
    headers["content-length"] = body.size.toString();
    headers["content-disposition"] = currentContentDisposition ?? generateContentDisposition(body instanceof File ? body.name : "blob");
    return Readable.fromWeb(body.stream());
  }
  if (body instanceof FormData) {
    const response = new Response(body);
    headers["content-type"] = response.headers.get("content-type");
    return Readable.fromWeb(response.body);
  }
  if (body instanceof URLSearchParams) {
    headers["content-type"] = "application/x-www-form-urlencoded";
    return body.toString();
  }
  if (isAsyncIteratorObject(body)) {
    headers["content-type"] = "text/event-stream";
    headers["cache-control"] = "no-cache";
    headers.connection = "keep-alive";
    return toEventStream(body, options);
  }
  headers["content-type"] = "application/json";
  return stringifyJSON(body);
}
function _streamToFormData(stream, contentType) {
  const response = new Response(stream, {
    headers: {
      "content-type": contentType
    }
  });
  return response.formData();
}
async function _streamToString(stream) {
  let string = "";
  for await (const chunk of stream) {
    string += chunk.toString();
  }
  return string;
}
async function _streamToFile(stream, fileName, contentType) {
  const chunks = [];
  for await (const chunk of stream) {
    chunks.push(chunk);
  }
  return new File(chunks, fileName, { type: contentType });
}

function toAbortSignal(res) {
  const controller = new AbortController();
  res.on("close", () => {
    if (res.errored) {
      controller.abort(res.errored.toString());
    } else if (!res.writableFinished) {
      controller.abort("Client connection prematurely closed.");
    } else {
      controller.abort("Server closed the connection.");
    }
  });
  return controller.signal;
}

function toStandardLazyRequest(req, res) {
  const method = req.method ?? "GET";
  const protocol = "encrypted" in req.socket && req.socket.encrypted ? "https:" : "http:";
  const host = req.headers.host ?? "localhost";
  const url = new URL(req.originalUrl ?? req.url ?? "/", `${protocol}//${host}`);
  return {
    method,
    url,
    headers: req.headers,
    body: once(() => toStandardBody(req)),
    signal: toAbortSignal(res)
  };
}

function sendStandardResponse(res, standardResponse, options = {}) {
  return new Promise((resolve, reject) => {
    res.on("error", reject);
    res.on("finish", resolve);
    const resHeaders = { ...standardResponse.headers };
    const resBody = toNodeHttpBody(standardResponse.body, resHeaders, options);
    res.writeHead(standardResponse.status, resHeaders);
    if (resBody === void 0) {
      res.end(resBody);
    } else if (typeof resBody === "string") {
      res.end(resBody);
    } else {
      res.on("close", () => {
        if (!resBody.closed) {
          resBody.destroy(res.errored ?? void 0);
        }
      });
      resBody.pipe(res);
    }
  });
}

export { sendStandardResponse, toAbortSignal, toEventIterator, toEventStream, toNodeHttpBody, toStandardBody, toStandardLazyRequest };
