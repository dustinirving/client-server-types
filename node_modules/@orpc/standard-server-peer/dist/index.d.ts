import { Promisable, AsyncIdQueueCloseOptions as AsyncIdQueueCloseOptions$1, CreateAsyncIteratorObjectCleanupFn } from '@orpc/shared';
import { StandardRequest, StandardResponse, EventMeta, StandardHeaders } from '@orpc/standard-server';

type EncodedMessage = string | ArrayBufferLike | Blob;
interface EncodedMessageSendFn {
    (message: EncodedMessage): Promisable<void>;
}

interface ClientPeerCloseOptions extends AsyncIdQueueCloseOptions$1 {
    /**
     * Should abort or not?
     *
     * @default true
     */
    abort?: boolean;
}
declare class ClientPeer {
    private readonly idGenerator;
    private readonly responseQueue;
    private readonly serverEventIteratorQueue;
    private readonly serverControllers;
    private readonly send;
    constructor(send: EncodedMessageSendFn);
    get length(): number;
    open(id: number): AbortController;
    request(request: StandardRequest): Promise<StandardResponse>;
    message(raw: EncodedMessage): Promise<void>;
    close(options?: AsyncIdQueueCloseOptions$1): void;
}

declare enum MessageType {
    REQUEST = 1,
    RESPONSE = 2,
    EVENT_ITERATOR = 3,
    ABORT_SIGNAL = 4
}
type EventIteratorEvent = 'message' | 'error' | 'done';
interface EventIteratorPayload {
    event: EventIteratorEvent;
    data: unknown;
    meta?: EventMeta;
}
interface RequestMessageMap {
    [MessageType.REQUEST]: Omit<StandardRequest, 'signal'>;
    [MessageType.EVENT_ITERATOR]: EventIteratorPayload;
    [MessageType.ABORT_SIGNAL]: void;
}
interface ResponseMessageMap {
    [MessageType.RESPONSE]: StandardResponse;
    [MessageType.EVENT_ITERATOR]: EventIteratorPayload;
    [MessageType.ABORT_SIGNAL]: void;
}
type DecodedMessageUnion<TMap extends RequestMessageMap | ResponseMessageMap> = {
    [K in keyof TMap]: [id: number, type: K, payload: TMap[K]];
}[keyof TMap];
type DecodedRequestMessage = DecodedMessageUnion<RequestMessageMap>;
type DecodedResponseMessage = DecodedMessageUnion<ResponseMessageMap>;
declare function encodeRequestMessage<T extends keyof RequestMessageMap>(id: number, type: T, payload: RequestMessageMap[T]): Promise<EncodedMessage>;
declare function decodeRequestMessage(raw: EncodedMessage): Promise<DecodedRequestMessage>;
declare function encodeResponseMessage<T extends keyof ResponseMessageMap>(id: number, type: T, payload: ResponseMessageMap[T]): Promise<EncodedMessage>;
declare function decodeResponseMessage(raw: EncodedMessage): Promise<DecodedResponseMessage>;
declare function isEventIteratorHeaders(headers: StandardHeaders): boolean;

interface AsyncIdQueueCloseOptions {
    id?: number;
    reason?: Error;
}
declare class AsyncIdQueue<T> {
    private readonly openIds;
    private readonly items;
    private readonly pendingPulls;
    get length(): number;
    open(id: number): void;
    isOpen(id: number): boolean;
    push(id: number, item: T): void;
    pull(id: number): Promise<T>;
    close({ id, reason }?: AsyncIdQueueCloseOptions): void;
    assertOpen(id: number): void;
}

declare function toEventIterator(queue: AsyncIdQueue<EventIteratorPayload>, id: number, cleanup: CreateAsyncIteratorObjectCleanupFn): AsyncGenerator;
declare function resolveEventIterator(iterator: AsyncIterator<any>, callback: (payload: EventIteratorPayload) => Promise<'next' | 'abort'>): Promise<void>;

interface ServerPeerCloseOptions extends AsyncIdQueueCloseOptions$1 {
    /**
     * Should abort or not?
     *
     * @default true
     */
    abort?: boolean;
}
declare class ServerPeer {
    private readonly clientEventIteratorQueue;
    private readonly clientControllers;
    private readonly send;
    constructor(send: EncodedMessageSendFn);
    get length(): number;
    open(id: number): AbortController;
    message(raw: EncodedMessage): Promise<[id: number, StandardRequest | undefined]>;
    response(id: number, response: StandardResponse): Promise<void>;
    close({ abort, ...options }?: ServerPeerCloseOptions): void;
}

export { ClientPeer, MessageType, ServerPeer, decodeRequestMessage, decodeResponseMessage, encodeRequestMessage, encodeResponseMessage, isEventIteratorHeaders, resolveEventIterator, toEventIterator };
export type { ClientPeerCloseOptions, DecodedRequestMessage, DecodedResponseMessage, EncodedMessage, EncodedMessageSendFn, EventIteratorEvent, EventIteratorPayload, RequestMessageMap, ResponseMessageMap, ServerPeerCloseOptions };
