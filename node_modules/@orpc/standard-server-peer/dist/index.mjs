import { isAsyncIteratorObject, stringifyJSON, createAsyncIteratorObject, isTypescriptObject, SequentialIdGenerator, AsyncIdQueue } from '@orpc/shared';
import { flattenHeader, getFilenameFromContentDisposition, generateContentDisposition, withEventMeta, ErrorEvent, getEventMeta } from '@orpc/standard-server';

var MessageType = /* @__PURE__ */ ((MessageType2) => {
  MessageType2[MessageType2["REQUEST"] = 1] = "REQUEST";
  MessageType2[MessageType2["RESPONSE"] = 2] = "RESPONSE";
  MessageType2[MessageType2["EVENT_ITERATOR"] = 3] = "EVENT_ITERATOR";
  MessageType2[MessageType2["ABORT_SIGNAL"] = 4] = "ABORT_SIGNAL";
  return MessageType2;
})(MessageType || {});
async function encodeRequestMessage(id, type, payload) {
  if (type === 3 /* EVENT_ITERATOR */) {
    const eventPayload = payload;
    const serializedPayload2 = {
      e: eventPayload.event,
      d: eventPayload.data,
      m: eventPayload.meta
    };
    return encodeRawMessage({ i: id, t: type, p: serializedPayload2 });
  }
  if (type === 4 /* ABORT_SIGNAL */) {
    return encodeRawMessage({ i: id, t: type, p: payload });
  }
  const request = payload;
  const { body: processedBody, headers: processedHeaders } = await prepareBodyAndHeadersForSerialization(
    request.body,
    request.headers
  );
  const serializedPayload = {
    u: request.url.toString().replace(/^orpc:\//, "/"),
    b: processedBody instanceof Blob ? void 0 : processedBody,
    h: Object.keys(processedHeaders).length > 0 ? processedHeaders : void 0,
    m: request.method === "POST" ? void 0 : request.method
  };
  const baseMessage = {
    i: id,
    p: serializedPayload
  };
  if (processedBody instanceof Blob) {
    return encodeRawMessage(baseMessage, processedBody);
  }
  return encodeRawMessage(baseMessage);
}
async function decodeRequestMessage(raw) {
  const { json: message, blobData } = await decodeRawMessage(raw);
  const id = message.i;
  const type = message.t;
  if (type === 3 /* EVENT_ITERATOR */) {
    const payload2 = message.p;
    return [id, type, { event: payload2.e, data: payload2.d, meta: payload2.m }];
  }
  if (type === 4 /* ABORT_SIGNAL */) {
    return [id, type, message.p];
  }
  const payload = message.p;
  const headers = payload.h ?? {};
  let body = payload.b;
  const contentType = flattenHeader(headers["content-type"]);
  if (blobData) {
    const contentDisposition = flattenHeader(headers["content-disposition"]);
    if (contentDisposition === void 0 && contentType?.startsWith("multipart/form-data")) {
      const tempRes = new Response(blobData, { headers: { "content-type": contentType } });
      body = await tempRes.formData();
    } else {
      const filename = getFilenameFromContentDisposition(contentDisposition) ?? "blob";
      body = new File([blobData], filename, { type: contentType });
    }
  } else if (contentType?.startsWith("application/x-www-form-urlencoded") && typeof body === "string") {
    body = new URLSearchParams(body);
  }
  return [id, 1 /* REQUEST */, { url: new URL(payload.u, "orpc:/"), headers, method: payload.m ?? "POST", body }];
}
async function encodeResponseMessage(id, type, payload) {
  if (type === 3 /* EVENT_ITERATOR */) {
    const eventPayload = payload;
    const serializedPayload2 = {
      e: eventPayload.event,
      d: eventPayload.data,
      m: eventPayload.meta
    };
    return encodeRawMessage({ i: id, t: type, p: serializedPayload2 });
  }
  if (type === 4 /* ABORT_SIGNAL */) {
    return encodeRawMessage({ i: id, t: type, p: void 0 });
  }
  const response = payload;
  const { body: processedBody, headers: processedHeaders } = await prepareBodyAndHeadersForSerialization(
    response.body,
    response.headers
  );
  const serializedPayload = {
    s: response.status === 200 ? void 0 : response.status,
    h: Object.keys(processedHeaders).length > 0 ? processedHeaders : void 0,
    b: processedBody instanceof Blob ? void 0 : processedBody
  };
  const baseMessage = {
    i: id,
    p: serializedPayload
  };
  if (processedBody instanceof Blob) {
    return encodeRawMessage(baseMessage, processedBody);
  }
  return encodeRawMessage(baseMessage);
}
async function decodeResponseMessage(raw) {
  const { json: message, blobData } = await decodeRawMessage(raw);
  const id = message.i;
  const type = message.t;
  if (type === 3 /* EVENT_ITERATOR */) {
    const payload2 = message.p;
    return [id, type, { event: payload2.e, data: payload2.d, meta: payload2.m }];
  }
  if (type === 4 /* ABORT_SIGNAL */) {
    return [id, type, message.p];
  }
  const payload = message.p;
  const headers = payload.h ?? {};
  let body = payload.b;
  const contentType = flattenHeader(headers["content-type"]);
  if (blobData) {
    const contentDisposition = flattenHeader(headers["content-disposition"]);
    if (contentDisposition === void 0 && contentType?.startsWith("multipart/form-data")) {
      const tempRes = new Response(blobData, { headers: { "content-type": contentType } });
      body = await tempRes.formData();
    } else {
      const filename = getFilenameFromContentDisposition(contentDisposition) ?? "blob";
      body = new File([blobData], filename, { type: contentType });
    }
  } else if (contentType?.startsWith("application/x-www-form-urlencoded") && typeof body === "string") {
    body = new URLSearchParams(body);
  }
  return [id, 2 /* RESPONSE */, { status: payload.s ?? 200, headers, body }];
}
async function prepareBodyAndHeadersForSerialization(body, originalHeaders) {
  const headers = { ...originalHeaders };
  const originalContentDisposition = headers["content-disposition"];
  delete headers["content-type"];
  delete headers["content-disposition"];
  if (body instanceof Blob) {
    headers["content-type"] = body.type;
    headers["content-disposition"] = originalContentDisposition ?? generateContentDisposition(
      body instanceof File ? body.name : "blob"
    );
    return { body, headers };
  }
  if (body instanceof FormData) {
    const tempRes = new Response(body);
    headers["content-type"] = tempRes.headers.get("content-type");
    const formDataBlob = await tempRes.blob();
    return { body: formDataBlob, headers };
  }
  if (body instanceof URLSearchParams) {
    headers["content-type"] = "application/x-www-form-urlencoded";
    return { body: body.toString(), headers };
  }
  if (isAsyncIteratorObject(body)) {
    headers["content-type"] = "text/event-stream";
    return { body: void 0, headers };
  }
  return { body, headers };
}
function isEventIteratorHeaders(headers) {
  return Boolean(flattenHeader(headers["content-type"])?.startsWith("text/event-stream") && headers["content-disposition"] === void 0);
}
const JSON_AND_BINARY_DELIMITER = 255;
async function encodeRawMessage(data, blobData) {
  const json = stringifyJSON(data);
  if (blobData === void 0) {
    return json;
  }
  return new Blob([
    new TextEncoder().encode(json),
    new Uint8Array([JSON_AND_BINARY_DELIMITER]),
    blobData
  ]);
}
async function decodeRawMessage(raw) {
  if (typeof raw === "string") {
    return { json: JSON.parse(raw) };
  }
  const buffer = new Uint8Array(raw instanceof Blob ? await raw.arrayBuffer() : raw);
  const delimiterIndex = buffer.indexOf(JSON_AND_BINARY_DELIMITER);
  if (delimiterIndex === -1) {
    const jsonPart2 = new TextDecoder().decode(buffer);
    return { json: JSON.parse(jsonPart2) };
  }
  const jsonPart = new TextDecoder().decode(buffer.slice(0, delimiterIndex));
  const blobData = buffer.slice(delimiterIndex + 1);
  return {
    json: JSON.parse(jsonPart),
    blobData
  };
}

function toEventIterator(queue, id, cleanup) {
  return createAsyncIteratorObject(async () => {
    const item = await queue.pull(id);
    switch (item.event) {
      case "message": {
        let data = item.data;
        if (item.meta && isTypescriptObject(data)) {
          data = withEventMeta(data, item.meta);
        }
        return { value: data, done: false };
      }
      case "error": {
        let error = new ErrorEvent({
          data: item.data
        });
        if (item.meta) {
          error = withEventMeta(error, item.meta);
        }
        throw error;
      }
      case "done": {
        let data = item.data;
        if (item.meta && isTypescriptObject(data)) {
          data = withEventMeta(data, item.meta);
        }
        return { value: data, done: true };
      }
    }
  }, cleanup);
}
async function resolveEventIterator(iterator, callback) {
  while (true) {
    const payload = await (async () => {
      try {
        const { value, done } = await iterator.next();
        if (done) {
          return { event: "done", data: value, meta: getEventMeta(value) };
        }
        return { event: "message", data: value, meta: getEventMeta(value) };
      } catch (err) {
        return {
          meta: getEventMeta(err),
          event: "error",
          data: err instanceof ErrorEvent ? err.data : void 0
        };
      }
    })();
    try {
      const direction = await callback(payload);
      if (payload.event === "done" || payload.event === "error") {
        return;
      }
      if (direction === "abort") {
        try {
          await iterator.return?.();
        } catch {
        }
        return;
      }
    } catch (err) {
      try {
        await iterator.return?.();
      } catch {
      }
      throw err;
    }
  }
}

class ClientPeer {
  idGenerator = new SequentialIdGenerator();
  responseQueue = new AsyncIdQueue();
  serverEventIteratorQueue = new AsyncIdQueue();
  serverControllers = /* @__PURE__ */ new Map();
  send;
  constructor(send) {
    this.send = async (id, ...rest) => encodeRequestMessage(id, ...rest).then(async (raw) => {
      if (this.serverControllers.has(id)) {
        await send(raw);
      }
    });
  }
  get length() {
    return (+this.responseQueue.length + this.serverEventIteratorQueue.length + this.serverControllers.size) / 3;
  }
  open(id) {
    this.serverEventIteratorQueue.open(id);
    this.responseQueue.open(id);
    const controller = new AbortController();
    this.serverControllers.set(id, controller);
    return controller;
  }
  async request(request) {
    const signal = request.signal;
    if (signal?.aborted) {
      throw signal.reason;
    }
    const id = this.idGenerator.generate();
    const serverController = this.open(id);
    return new Promise((resolve, reject) => {
      this.send(id, MessageType.REQUEST, request).then(async () => {
        if (signal?.aborted) {
          await this.send(id, MessageType.ABORT_SIGNAL, void 0);
          this.close({ id, reason: signal.reason });
          return;
        }
        signal?.addEventListener("abort", async () => {
          await this.send(id, MessageType.ABORT_SIGNAL, void 0);
          this.close({ id, reason: signal.reason });
        }, { once: true });
        if (isAsyncIteratorObject(request.body)) {
          await resolveEventIterator(request.body, async (payload) => {
            if (serverController.signal.aborted) {
              return "abort";
            }
            await this.send(id, MessageType.EVENT_ITERATOR, payload);
            return "next";
          });
        }
      }).catch((err) => {
        this.close({ id, reason: err });
        reject(err);
      });
      this.responseQueue.pull(id).then(resolve).catch(reject);
    });
  }
  async message(raw) {
    const [id, type, payload] = await decodeResponseMessage(raw);
    if (type === MessageType.ABORT_SIGNAL) {
      this.serverControllers.get(id)?.abort();
      return;
    }
    if (type === MessageType.EVENT_ITERATOR) {
      if (this.serverEventIteratorQueue.isOpen(id)) {
        this.serverEventIteratorQueue.push(id, payload);
      }
      return;
    }
    if (!this.responseQueue.isOpen(id)) {
      return;
    }
    if (isEventIteratorHeaders(payload.headers)) {
      this.responseQueue.push(id, {
        ...payload,
        body: toEventIterator(this.serverEventIteratorQueue, id, async (reason) => {
          try {
            if (reason !== "next") {
              await this.send(id, MessageType.ABORT_SIGNAL, void 0);
            }
          } finally {
            this.close({ id });
          }
        })
      });
    } else {
      this.responseQueue.push(id, payload);
      this.close({ id });
    }
  }
  close(options = {}) {
    if (options.id !== void 0) {
      this.serverControllers.get(options.id)?.abort(options.reason);
      this.serverControllers.delete(options.id);
    } else {
      this.serverControllers.forEach((c) => c.abort(options.reason));
      this.serverControllers.clear();
    }
    this.responseQueue.close(options);
    this.serverEventIteratorQueue.close(options);
  }
}

class ServerPeer {
  clientEventIteratorQueue = new AsyncIdQueue();
  clientControllers = /* @__PURE__ */ new Map();
  send;
  constructor(send) {
    this.send = (id, ...rest) => encodeResponseMessage(id, ...rest).then(async (raw) => {
      if (this.clientControllers.has(id)) {
        await send(raw);
      }
    });
  }
  get length() {
    return (this.clientEventIteratorQueue.length + this.clientControllers.size) / 2;
  }
  open(id) {
    this.clientEventIteratorQueue.open(id);
    const controller = new AbortController();
    this.clientControllers.set(id, controller);
    return controller;
  }
  async message(raw) {
    const [id, type, payload] = await decodeRequestMessage(raw);
    if (type === MessageType.ABORT_SIGNAL) {
      this.close({ id });
      return [id, void 0];
    }
    if (type === MessageType.EVENT_ITERATOR) {
      if (this.clientEventIteratorQueue.isOpen(id)) {
        this.clientEventIteratorQueue.push(id, payload);
      }
      return [id, void 0];
    }
    const clientController = this.open(id);
    const request = {
      ...payload,
      signal: clientController.signal,
      body: isEventIteratorHeaders(payload.headers) ? toEventIterator(this.clientEventIteratorQueue, id, async (reason) => {
        if (reason !== "next") {
          await this.send(id, MessageType.ABORT_SIGNAL, void 0);
        }
      }) : payload.body
    };
    return [id, request];
  }
  async response(id, response) {
    const signal = this.clientControllers.get(id)?.signal;
    if (!signal || signal.aborted) {
      return;
    }
    await this.send(id, MessageType.RESPONSE, response).then(async () => {
      if (!signal.aborted && isAsyncIteratorObject(response.body)) {
        await resolveEventIterator(response.body, async (payload) => {
          if (signal.aborted) {
            return "abort";
          }
          await this.send(id, MessageType.EVENT_ITERATOR, payload);
          return "next";
        });
      }
      this.close({ id, abort: false });
    }).catch((reason) => {
      this.close({ id, reason, abort: false });
      throw reason;
    });
  }
  close({ abort = true, ...options } = {}) {
    if (options.id === void 0) {
      if (abort) {
        this.clientControllers.forEach((c) => c.abort());
      }
      this.clientControllers.clear();
    } else {
      if (abort) {
        this.clientControllers.get(options.id)?.abort();
      }
      this.clientControllers.delete(options.id);
    }
    this.clientEventIteratorQueue.close(options);
  }
}

export { ClientPeer, MessageType, ServerPeer, decodeRequestMessage, decodeResponseMessage, encodeRequestMessage, encodeResponseMessage, isEventIteratorHeaders, resolveEventIterator, toEventIterator };
